*  Дефинирайте:

1. Константата assoc-empty, която съответства на празен асоциативен списък

2. Функцията (assoc-set l k v), която връща нов асоциативен списък, който представлява l с добавена двойка с ключ k и стойност v.
   Примери:
   (assoc-set '((foo . 1) (bar . 2)) 'qux 3) -> ((foo . 1) (bar . 2) (qux . 3))
   (assoc-set '((foo . 1) (bar . 2)) 'foo 3) -> ((foo . 3) (bar . 2))
   
3. Функцията (assoc-get l k), която по даден ключ връща стойността, асоциирана с него (ако такъв ключ не съществува, връща #f)

4. Функцията (assoc-map f l), която връща нов асоциативен списък, който е резултатът от прилагането на f върху стойностите в l.

5. Функцията (assoc-filter p l), която връща нов асоциативен списък, който съдържа само двойките, за чиято стойност p връща "истина"

6. Предиката (assoc? l), който проверява дали l е валиден асоциативен списък

7. Функцията (assoc-merge l1 l2), която връща нов асоциативен списък, за който:
   множеството от ключове е обединението на ключовете на l1 и l2 ако (k . v) се среща в l2, то (k . v) се среща в резултата
   иначе, ако (k . v) се среща в l1, то (k . v) се среща в резултата
   
8. Функцията (assoc-merge-resolve f l1 l2), която работи подобно на assoc-merge, обаче използва функцията f, за да разреши конфликтите:
   ако ключът k се среща в l1 със стойност v1 и в l2 със стойност v2, трябва да извикаме (f k v1 v2), която ще върне стойността, която трябва да стои зад k в новия 
   списък. ако ключът k се среща само в единият от l1 или l2, процедираме както при assoc-merge и не използваме f
   
   a) Функцията (assoc-merge2 l1 l2), която работи по същия начин като assoc-merge, но използва assoc-merge-resolve, подавайки подходящо f.

   b) Функцията (assoc-merge-sum l1 l2), която работи върху асоциативни списъци, чиито стойности са числа, и използва assoc-merge-resolve за да върне сбора на 
   двете стойности, когато ключът се среща и в двата списъка.
