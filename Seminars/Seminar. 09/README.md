Имплементирайте следните функции:

1. fact :: Int -> Int, където fact n изчислява факториел от n

2. fib :: Int -> Int, където fib n изчислява n-тото число на фибоначи

3. myAbs :: Int -> Int, където abs n изчислява модул от n

4. composeInt :: (Int -> Int) -> (Int -> Int) -> (Int -> Int), където composeInt f g връща функция, която е композицията на едноаргументните     
   функции върху цели числа f и g

5. compose, която е като composeInt, но работи за произволни входни данни (измислете типа)

6. myConcat :: [a] -> [a] -> [a], която съединява два списъка

7. isIntPrefix :: [Int] -> [Int] -> Bool, която проверява дали първият подаден списък е префикс на втория

8. isPrefix :: (Eq a) => [a] -> [a] -> Bool, която работи като isIntPrefix, но за произволни входни данни (тук трябва обяснение за типови класове)

9. frepeat :: Int -> (a -> a) -> a -> a, където repeat n f x е резултата от прилагането на f върху x n пъти

10. frepeated, където repeat n f връща функция, която действа като n пъти прилагане на f (измислете типа)
